#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        PH_PhotonCounter.py
## 
## Project :     PicoHarp photon counter
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""This device has been conceived to introduce a PicoHarp300 instrument 
with in the tango control system.

This device is not using directly the manufacturer's library. In this repository
you can find a cython extension to bind their library to python."""

__all__ = ["PH_PhotonCounter", "PH_PhotonCounterClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(PH_PhotonCounter.additionnal_import) ENABLED START -----#

import math
import numpy as np
import PicoHarp
import pprint #used for Exec()
from subprocess import call
#from usbreset import usbreset
import threading
import time
import traceback
from types import StringType #used for Exec()


TIME_BETWEEN_CHANGING = 0.1 #s
DEFAULT_TIME_BETWEEN_CHANGING = TIME_BETWEEN_CHANGING
MIN_TIME_BETWEEN_CHANGING = TIME_BETWEEN_CHANGING
TIME_HOLD_ALARM = 1 #s
DEFAULT_TIME_HOLD_ALARM = TIME_HOLD_ALARM
MIN_TIME_HOLD_ALARM = TIME_HOLD_ALARM
#----- PROTECTED REGION END -----#	//	PH_PhotonCounter.additionnal_import

## Device States Description
## ALARM : Alert that something is not going as expected, but it's not blocking.
## FAULT : Decay state when something went wrong. Requires Init().
## INIT : Initialization process.
## OFF : Instrument discovered, but not yet open communication.
## ON : Instrument available (or simulated).
## RUNNING : An acquisition is going on.
## STANDBY : In a continuous acquisition this is the intermediate state.

class PH_PhotonCounter (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(PH_PhotonCounter.global_variables) ENABLED START -----#
    _important_logs = []
    #---- Events region
    def set_state(self, newState):
        '''Overload of the superclass method to add event 
           emission functionality.
        '''
        if self.get_state() != newState:
            self.warn_stream("Change state from %s to %s"
                             %(self.get_state(),newState))
            PyTango.Device_4Impl.set_state(self, newState)
            self.push_change_event('State',newState)
            self.set_status("")
    def set_status(self, newLine2status,important=False):
        '''Overload of the superclass method to add the extra feature of
           the persistent messages added to the status string.
        '''
        #self.debug_stream("In set_status()")
        newStatus = ""#The device is in %s state.\n"%(self.get_state())
        for importantMsg in self._important_logs:
            if len(importantMsg) > 0:
                newStatus = "%s%s\n"%(newStatus,importantMsg)
        if len(newLine2status) > 0 and \
           not newLine2status in self._important_logs:
            newStatus = "%s%s\n"%(newStatus,newLine2status)
            if important:
                self._important_logs.append(newLine2status)
        if len(newStatus) == 0:
            newStatus = "The device is in %s state.\n"%(self.get_state())
        oldStatus = self.get_status()
        if newStatus != oldStatus:
            PyTango.Device_4Impl.set_status(self, newStatus)
            self.warn_stream("New status message: %s"
                              %(repr(self.get_status())))
            self.push_change_event('Status',newStatus)
    def clean_status(self):
        '''With the extra feature of the important logs, this method allows
           to clean all those logs as a clean interlocks method does.
        '''
        self.debug_stream("In clean_status()")
        self._important_logs = []
        self.set_status("")
    def fireEvent(self,attrEventStruct,timestamp=None):
        '''Method with the procedure to emit an event from one existing 
           attribute. Minimal needs are the attribute name and the value
           to emit, but also can be specified the quality and the timestamp
        '''
        if timestamp == None:
            timestamp = time.time()
        #self.debug_stream("In fireEvent() attribute %s"
        #                  %(attrEventStruct[0]))
        if len(attrEventStruct) == 3: #the quality is specified
            self.push_change_event(attrEventStruct[0],attrEventStruct[1],
                                   timestamp,
                                   attrEventStruct[2])
        else:
            self.push_change_event(attrEventStruct[0],attrEventStruct[1],
                                   timestamp,
                                   PyTango.AttrQuality.ATTR_VALID)
    
    def fireEventsList(self,eventsAttrList,log=True):
        '''Given a set of pair [attr,value] (with an optional third element
           with the quality) emit events for all of them with the same
           timestamp.
        '''
        if log:
            self.debug_stream("In fireEventsList():\n%s"
                              %(''.join("\t%s\n"
                                        %self._debugAttributeEvent(line) \
                                        for line in eventsAttrList)))
        timestamp = time.time()
        attrNames = []
        for attrEvent in eventsAttrList:
            try:
                self.fireEvent(attrEvent,timestamp)
                attrNames.append(attrEvent[0])
            except Exception,e:
                self.error_stream("In fireEventsList() Exception with "\
                                  "attribute %s: %s"%(attrEvent[0],e))
    def _debugAttributeEvent(self,attrEventStruct):
        if type(attrEventStruct[1]) == list and len(attrEventStruct[1])>21:
            if len(attrEventStruct) == 3:
                return '[\'%s\',%s (...) %s (len %d),%s]'%(attrEventStruct[0],
                                             repr(attrEventStruct[1][:7])[:-1],
                                             repr(attrEventStruct[1][-7:])[1:],
                                             len(attrEventStruct[1]),
                                             attrEventStruct[2])
            else:
                return '[\'%s\',%s (...) %s (len %d)]'%(attrEventStruct[0],
                                             repr(attrEventStruct[1][:7])[:-1],
                                             repr(attrEventStruct[1][-7:])[1:],
                                             len(attrEventStruct[1]))
        else:
            if len(attrEventStruct) == 3:
                return '[\'%s\',%s,%s]'%(attrEventStruct[0],
                                         repr(attrEventStruct[1]),
                                         attrEventStruct[2])
            else:
                return '[\'%s\',%s]'%(attrEventStruct[0],
                                         repr(attrEventStruct[1]))
    def getTimeBetweenChanging(self):
        if self.attr_TimeBetweenChanging_read == 0:
            self.attr_TimeBetweenChanging_read = DEFAULT_TIME_BETWEEN_CHANGING
        return self.attr_TimeBetweenChanging_read
    def setTimeBetweenChangin(self,value):
        if value < MIN_TIME_BETWEEN_CHANGING:
            value = MIN_TIME_BETWEEN_CHANGING
        if value != self.attr_TimeBetweenChanging_read:
            self.fireEventsList([['TimeBetweenChanging',value]])
        self.attr_TimeBetweenChanging_read = value
    def getTimeHoldingAlarm(self):
        if self.attr_TimeHoldingAlarm_read == 0:
            self.attr_TimeHoldingAlarm_read = DEFAULT_TIME_HOLD_ALARM
        return self.attr_TimeHoldingAlarm_read
    def setTimeHoldingAlarm(self,value):
        if value < MIN_TIME_HOLD_ALARM:
            value = MIN_TIME_HOLD_ALARM
        if value != self.attr_TimeHoldingAlarm_read:
            self.fireEventsList([['TimeHoldingAlarm',value]])
        self.attr_TimeHoldingAlarm_read = value
    #---- Done events region

    #---- Instrument connectivity region
    def discover(self):
        self._discoverer = PicoHarp.Discoverer(debug=True)
        if not self.SerialNumber in self._discoverer.serials:
            msg = "Not found serial %s in list %s"\
                  %(self.SerialNumber,self._discoverer.serials)
            self.debug_stream(msg)
            if not self.Simulation:
                self.set_state(PyTango.DevState.FAULT)
                self.set_status(msg)
                return False
        self.set_state(PyTango.DevState.STANDBY)
        return True
    def connect(self):
        try:
            if not self.Simulation:
                self._devidx = self._discoverer.search(self.SerialNumber)
                self._instrument = PicoHarp.Instrument(self._devidx,debug=True)
            else:
                self._instrument = PicoHarp.InstrumentSimulator(debug=True)
            self.set_state(PyTango.DevState.ON)
            self.fireEventsList([
                     ['InstrumentModel',self._instrument.__model__],
                     ['InstrumentPartnum',self._instrument.__partnum__],
                     ['InstrumentVersion',self._instrument.__version__],
                     ['BaseResolution',self._instrument.getBaseResolution()]
                                ])
        except Exception,e:
            self.set_state(PyTango.DevState.FAULT)
            self.set_status("Connection failed due to: %s"%(e), important=True)
        
    def disconnect(self):
        if hasattr(self,'_instrument') and self._instrument != None:
            if not self._instrument.isAsyncAcquisitionDone():
                self._instrument.abort()
            del self._instrument
            self._instrument = None
        if not self.get_state() in [PyTango.DevState.OFF,
                                    PyTango.DevState.FAULT]:
            self.set_state(PyTango.DevState.OFF)
    def isConnected(self):
        if hasattr(self,'_instrument') and self._instrument != None:
            return True
        return False
    
    def _usbRecovery(self):
        #usb = usbreset()
        #usb.unbind()
        #usb.bind()
        try:
            #FIXME: unhardcode!
            call(["/homelocal/sicilia/local/tmp/usbreset.sh"])
        except Exception,e:
            self.error_stream("Exception trying to recover from usb issue.")
            self.set_status(PyTango.DevState.FAULT)
            self.set_status("Fatal error. Cannot recover USB communications.",
                            important=True)
        else:
            self.disconnect()
            self.set_state(PyTango.DevState.INIT)
            if self._communicationsThread.isAlive():
                if self._communicationsThread.join(0.1):#s
                    try:
                        self._communicationsThread.exit()
                    except Exception,e:
                        self.warn_stream("Couldn't finish the "\
                                         "communication thread")
            self._communicationsThread = None
            self._prepareThreading()
            self._prepareDiscoverInstrument()
            self._launchThread()
    #---- Done instrument connectivity region
    
    #---- Threaded acquisition region
    def _prepareThreading(self):
        if not hasattr(self,'_acquisitionThread'):
            self._acquisitionThread = None
        if not hasattr(self,'_acquisitionStop'):
            self._acquisitionStop = threading.Event()
            self._acquisitionStop.clear()
        if not hasattr(self,'_communicationsThread') or \
        self._communicationsThread == None:
            self._communicationsThread = \
                           threading.Thread(target=self._prepareCommunications)

    def _launchThread(self):
        try:
            if not self._communicationsThread.isAlive():
                self._communicationsThread.start()
        except RuntimeError,e:
            self.warn_stream("Error launching thread because: %s"%(e))
        
    def _prepareDiscoverInstrument(self):
        if not hasattr(self,'_discoverer'):
            self._discoverer = None
        if not hasattr(self,'_devidx'):
            self._devidx = None
        if not hasattr(self,'_instrument'):
            self._instrument = None

    def _prepareCommunications(self):
        if not self._discoverer:
            if not self.discover():
                while not self.discover():
                    time.sleep(1)
                    self.warn_stream("Discoverer didn't find the instrument")
        if hasattr(self,'_instrument') and self._instrument == None:
            self.connect()
            self._poststandby()
            
    def _poststandby(self):
        self._checkSyncDivider()
        self._checkZeroCrossChannels()
        self._checkLevelChannels()
        self._checkResolutionAndBinning()
        self._checkOffset()
        self._checkOverflowStopper()
        self._checkAcquisitionTime()
        
    def _checkSyncDivider(self):
        if self.attr_SyncDivider_read != self._instrument.getSyncDivider():
            self.debug_stream("Appyling stored SyncDivider = %g"
                              %(self.attr_SyncDivider_read))
            self._instrument.setSyncDivider(self.attr_SyncDivider_read)
    def _checkZeroCrossChannels(self):
        ZeroCross,level = self._instrument.getInputCFD(0)
        if self.attr_ZeroCrossCh0_read != ZeroCross:
            self.debug_stream("Appyling stored ZeroCrossCh0 = %g"
                              %(self.attr_ZeroCrossCh0_read))
            self._instrument.setInputCFD(0,\
                                      CFDZeroCross=self.attr_ZeroCrossCh0_read)
        ZeroCross,level = self._instrument.getInputCFD(1)
        if self.attr_ZeroCrossCh1_read != ZeroCross:
            self.debug_stream("Appyling stored ZeroCrossCh1 = %g"
                              %(self.attr_ZeroCrossCh1_read))
            self._instrument.setInputCFD(1,\
                                      CFDZeroCross=self.attr_ZeroCrossCh1_read)
    def _checkLevelChannels(self):
        ZeroCross,level = self._instrument.getInputCFD(0)
        if self.attr_LevelCh0_read != level:
            self.debug_stream("Appyling stored LevelCh0 = %g"
                              %(self.attr_LevelCh0_read))
            self._instrument.setInputCFD(0,\
                                          CFDLevel=self.attr_LevelCh0_read)
        ZeroCross,level = self._instrument.getInputCFD(1)
        if self.attr_LevelCh1_read != level:
            self.debug_stream("Appyling stored LevelCh1 = %g"
                              %(self.attr_LevelCh1_read))
            self._instrument.setInputCFD(1,\
                                          CFDLevel=self.attr_LevelCh1_read)
    def _checkResolutionAndBinning(self):
        if self.attr_Resolution_read != self._instrument.getResolution():
            try:
                binning = \
                     self._fromResolutionKnowBinning(self.attr_Resolution_read)
                self.debug_stream("Appyling stored Resolution = %g"
                                  %(self.attr_Resolution_read))
                self._instrument.setBinning(binning)
            except:
                if self.attr_Binning_read != self._instrument.getBinning():
                    self.debug_stream("Appyling stored Binning = %g"
                                      %(self.attr_Binning_read))
                    self._instrument.setBinning(self.attr_Binning_read)

    def _fromResolutionKnowBinning(self,resolution):
        baseResolution = self._instrument.getBaseResolution()
        if resolution < baseResolution:
            raise Exception("Resolution cannot go below the base "\
                            "resolution (%f)"%baseResolution)
        #inverse of resolution=baseResolution*(2**binning)
        #and round the result to the closest binning
        return int(math.ceil(math.log(resolution/baseResolution,2)))
    
    def _checkOffset(self):
        if self.attr_Offset_read != self._instrument.getOffset():
            self.debug_stream("Appyling stored Offset = %g"
                              %(self.attr_Offset_read))
            self._instrument.setOffset(self.attr_Offset_read)
    
    def _checkOverflowStopper(self):
        stopper,threshold = self._instrument.getStopOverflow()
        if self.attr_OverflowStopper_read != stopper:
            self.debug_stream("Appyling stored OverflowStopper = %g"
                              %(self.attr_OverflowStopper_read))
            self._instrument.\
                           setStopOverflow(stop=self.attr_OverflowStopper_read)
        if self.attr_OverflowStopperThreshold_read > 0 and \
                          self.attr_OverflowStopperThreshold_read != threshold:
            self.debug_stream("Appyling stored OverflowStopperThreshold = %g"
                              %(self.attr_OverflowStopperThreshold_read))
            self._instrument.\
                 setStopOverflow(count=self.attr_OverflowStopperThreshold_read)
    def _checkAcquisitionTime(self):
        if self.attr_AcquisitionTime_read != \
                                   self._instrument.getAcquisitionTime()/1000.:
            self.debug_stream("Appyling stored AcquisitionTime = %g"
                              %(self.attr_AcquisitionTime_read))
            self._instrument.setAcquisitionTime(\
                                      int(self.attr_AcquisitionTime_read*1000))
            
    def fireAcqusitionEvents(self,quality=PyTango.AttrQuality.ATTR_VALID):
        countRate = self._instrument.getCountRates()
        flags = self._instrument.getFlags()
        IntegralCount = self._instrument.integralCount()
        histogram = self._instrument.getHistogram()
        HistogramMaxValue = long(np.array(histogram).max())
        ElapsedMeasTime = self._instrument.getElapsedMeasTime()/1000.
        self.fireEventsList([['CountRateCh0',countRate[0],quality],
                             ['CountRateCh1',countRate[1],quality],
                             ['Flags',flags,quality],
                             ['IntegralCount',IntegralCount,quality],
                             ['ElapsedMeasTime',ElapsedMeasTime,quality],
                             ['HistogramMaxValue',HistogramMaxValue,quality],
                             ['Histogram',histogram,quality]])
    
    def singleAcquisition(self):
        self.clean_status()
        self._acquisitionThread = threading.Thread(target=self._doSingleAcq)
        self._acquisitionStop.clear()
        self._acquisitionThread.start()
        
    def _doSingleAcq(self,endState=PyTango.DevState.ON):
        try:
            self.set_state(PyTango.DevState.RUNNING)
            self._instrument.acquire(async=True)
            while not self._instrument.isAsyncAcquisitionDone():
                if self._acquisitionStop.isSet():
                    self.warn_stream("Proceeding with Abort()")
                    self._instrument.abort()
                    break
                time.sleep(self.getTimeBetweenChanging())
                #launch events with "changing" quality
                self.fireAcqusitionEvents(PyTango.AttrQuality.ATTR_CHANGING)
            #launch final events with quality "valid"
            self.fireAcqusitionEvents()
            warnings = self._instrument.getWarnings()
            if warnings != 0:
                self.fireEventsList([['Warnings',self._instrument.getWarningsText(warnings)]])
                self.set_state(PyTango.DevState.ALARM)
            else:
                self.set_state(endState)
        except IOError,e:
            msg = "Catch IOError exception: %s"%(e)
            self.error_stream(msg)
            #traceback.print_exc()
            #TODO: try to recover this exception
            if e.errno in [PicoHarp.ErrorCodes.USB_HISPEED_FAIL,
                           PicoHarp.ErrorCodes.USB_VCMD_FAIL]:
                self.error_stream("Catch an error with the USB control "\
                                 "(e.errno = %r, e.strerror = %r). "\
                                 "Let's try if it can be recovered."
                                 %(e.errno,e.strerror))
                self._usbRecovery()
                return
            self.set_state(PyTango.DevState.FAULT)
            self.set_status(msg)
            self._acquisitionStop.set()
        except Exception,e:
            msg = "Acquisition exception: %s"%(e)
            self.error_stream(msg)
            self.set_state(PyTango.DevState.FAULT)
            self.set_status(msg)
            self._acquisitionStop.set()

    def continuousAcquisition(self):
        self.clean_status()
        self._acquisitionStop.clear()
        self._acquisitionThread = threading.Thread(target=self._doContinuousAcq)
        self._acquisitionThread.start()
        
    def _doContinuousAcq(self):
        self.set_state(PyTango.DevState.STANDBY)
        while not self._acquisitionStop.isSet():
            self._doSingleAcq(endState=PyTango.DevState.STANDBY)
            if self.get_state() == PyTango.DevState.ALARM:
                #in case of alarms, extend the time between acq to 
                #allow the alarm to be saw.
                time.sleep(self.getTimeHoldingAlarm())
        if self.get_state() != PyTango.DevState.FAULT:
            self.set_state(PyTango.DevState.ON)
    #---- Done threaded acquisition region
    
    #---- Dynamic attributes region
    def initialize_dynamic_attributes(self):
        pass
    #---- Done dynamic attributes region
#----- PROTECTED REGION END -----#	//	PH_PhotonCounter.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        PH_PhotonCounter.init_device(self)
        #----- PROTECTED REGION ID(PH_PhotonCounter.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.delete_device) ENABLED START -----#
        self.disconnect()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_InstrumentModel_read = ''
        self.attr_InstrumentPartnum_read = ''
        self.attr_InstrumentVersion_read = ''
        self.attr_SyncDivider_read = 0
        self.attr_ZeroCrossCh0_read = 0
        self.attr_ZeroCrossCh1_read = 0
        self.attr_LevelCh0_read = 0
        self.attr_LevelCh1_read = 0
        self.attr_Resolution_read = 0.0
        self.attr_Binning_read = 0
        self.attr_BaseResolution_read = 0.0
        self.attr_Offset_read = 0
        self.attr_CountRateCh0_read = 0
        self.attr_CountRateCh1_read = 0
        self.attr_OverflowStopper_read = False
        self.attr_OverflowStopperThreshold_read = 0
        self.attr_AcquisitionTime_read = 0.0
        self.attr_Flags_read = 0
        self.attr_IntegralCount_read = 0
        self.attr_HistogramMaxValue_read = 0
        self.attr_ElapsedMeasTime_read = 0.0
        self.attr_Warnings_read = ''
        self.attr_HardwareDebugInfo_read = ''
        self.attr_TimeBetweenChanging_read = 0.0
        self.attr_TimeHoldingAlarm_read = 0.0
        self.attr_Histogram_read = [0]
        #----- PROTECTED REGION ID(PH_PhotonCounter.init_device) ENABLED START -----#
        self.set_change_event('State', True, False)
        self.set_change_event('Status', True, False)
        self.set_state(PyTango.DevState.INIT)
        #RW attribute with event emission when write.
        self.set_change_event('SyncDivider', True, False)
        self.set_change_event('ZeroCrossCh0', True, False)
        self.set_change_event('ZeroCrossCh1', True, False)
        self.set_change_event('LevelCh0', True, False)
        self.set_change_event('LevelCh1', True, False)
        self.set_change_event('Resolution', True, False)
        self.set_change_event('Binning', True, False)
        self.set_change_event('Offset', True, False)
        self.set_change_event('OverflowStopper', True, False)
        self.set_change_event('OverflowStopperThreshold', True, False)
        self.set_change_event('AcquisitionTime', True, False)
        #RO attributes (should never change) emitted in the connection builder
        self.set_change_event('InstrumentModel', True, False)
        self.set_change_event('InstrumentPartnum', True, False)
        self.set_change_event('InstrumentVersion', True, False)
        self.set_change_event('BaseResolution', True, False)
        #RO attributes from measurements:
        self.set_change_event('CountRateCh0', True, False)
        self.set_change_event('CountRateCh1', True, False)
        self.set_change_event('Flags', True, False)
        self.set_change_event('IntegralCount', True, False)
        self.set_change_event('HistogramMaxValue', True, False)
        self.set_change_event('Histogram', True, False)
        self.set_change_event('ElapsedMeasTime', True, False)
        self.set_change_event('Warnings', True, False)
        #Expert internal attributes
        self.set_change_event('TimeBetweenChanging',True,False)
        self.set_change_event('TimeHoldingAlarm',True,False)
        self._locals = { 'self' : self }
        self._globals = globals()
        #some ifs to protect call init when already running
        self._prepareThreading()
        self._prepareDiscoverInstrument()
        self.set_state(PyTango.DevState.OFF)
        self._launchThread()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.always_executed_hook

    #-----------------------------------------------------------------------------
    #    PH_PhotonCounter read/write attribute methods
    #-----------------------------------------------------------------------------
    
    def read_InstrumentModel(self, attr):
        self.debug_stream("In read_InstrumentModel()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.InstrumentModel_read) ENABLED START -----#
        self.attr_InstrumentModel_read = self._instrument.__model__
        attr.set_value(self.attr_InstrumentModel_read)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.InstrumentModel_read
        
    def is_InstrumentModel_allowed(self, attr):
        self.debug_stream("In is_InstrumentModel_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_InstrumentModel_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_InstrumentModel_allowed
        return state_ok
        
    def read_InstrumentPartnum(self, attr):
        self.debug_stream("In read_InstrumentPartnum()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.InstrumentPartnum_read) ENABLED START -----#
        self.attr_InstrumentPartnum_read = self._instrument.__partnum__
        attr.set_value(self.attr_InstrumentPartnum_read)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.InstrumentPartnum_read
        
    def is_InstrumentPartnum_allowed(self, attr):
        self.debug_stream("In is_InstrumentPartnum_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_InstrumentPartnum_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_InstrumentPartnum_allowed
        return state_ok
        
    def read_InstrumentVersion(self, attr):
        self.debug_stream("In read_InstrumentVersion()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.InstrumentVersion_read) ENABLED START -----#
        self.attr_InstrumentVersion_read = self._instrument.__version__
        attr.set_value(self.attr_InstrumentVersion_read)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.InstrumentVersion_read
        
    def is_InstrumentVersion_allowed(self, attr):
        self.debug_stream("In is_InstrumentVersion_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_InstrumentVersion_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_InstrumentVersion_allowed
        return state_ok
        
    def read_SyncDivider(self, attr):
        self.debug_stream("In read_SyncDivider()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.SyncDivider_read) ENABLED START -----#
        try:
            self.attr_SyncDivider_read = self._instrument.getSyncDivider()
            attr.set_value(self.attr_SyncDivider_read)
        except Exception,e:
            self.set_status("Exception with SyncDivider: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.SyncDivider_read
        
    def write_SyncDivider(self, attr):
        self.debug_stream("In write_SyncDivider()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.SyncDivider_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setSyncDivider(data)
                self.attr_SyncDivider_read = self._instrument.getSyncDivider()
                self.fireEventsList([['SyncDivider',self.attr_SyncDivider_read]])
            else:
                self.attr_SyncDivider_read = data
        except Exception,e:
            self.error_stream("Exception with SyncDivider: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.SyncDivider_write
        
    def is_SyncDivider_allowed(self, attr):
        self.debug_stream("In is_SyncDivider_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_SyncDivider_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_SyncDivider_allowed
        return state_ok
        
    def read_ZeroCrossCh0(self, attr):
        self.debug_stream("In read_ZeroCrossCh0()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.ZeroCrossCh0_read) ENABLED START -----#
        try:
            self.attr_ZeroCrossCh0_read, level = self._instrument.getInputCFD(0)
            attr.set_value(self.attr_ZeroCrossCh0_read)
        except Exception,e:
            self.set_status("Exception with ZeroCrossCh0: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.ZeroCrossCh0_read
        
    def write_ZeroCrossCh0(self, attr):
        self.debug_stream("In write_ZeroCrossCh0()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.ZeroCrossCh0_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setInputCFD(0,CFDZeroCross=data)
                self.attr_ZeroCrossCh0_read, level = self._instrument.getInputCFD(0)
                self.fireEventsList([['ZeroCrossCh0',self.attr_ZeroCrossCh0_read]])
            else:
                self.attr_ZeroCrossCh0_read = data
        except Exception, e:
            self.error_stream("Exception with ZeroCrossCh0: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.ZeroCrossCh0_write
        
    def is_ZeroCrossCh0_allowed(self, attr):
        self.debug_stream("In is_ZeroCrossCh0_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_ZeroCrossCh0_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_ZeroCrossCh0_allowed
        return state_ok
        
    def read_ZeroCrossCh1(self, attr):
        self.debug_stream("In read_ZeroCrossCh1()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.ZeroCrossCh1_read) ENABLED START -----#
        try:
            self.attr_ZeroCrossCh1_read, level = self._instrument.getInputCFD(1)
            attr.set_value(self.attr_ZeroCrossCh1_read)
        except Exception,e:
            self.set_status("Exception with ZeroCrossCh1: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.ZeroCrossCh1_read
        
    def write_ZeroCrossCh1(self, attr):
        self.debug_stream("In write_ZeroCrossCh1()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.ZeroCrossCh1_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setInputCFD(1,CFDZeroCross=data)
                self.attr_ZeroCrossCh1_read, level = self._instrument.getInputCFD(1)
                self.fireEventsList([['ZeroCrossCh1',self.attr_ZeroCrossCh1_read]])
            else:
                self.attr_ZeroCrossCh1_read = data
        except Exception, e:
            self.error_stream("Exception with ZeroCrossCh1: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.ZeroCrossCh1_write
        
    def is_ZeroCrossCh1_allowed(self, attr):
        self.debug_stream("In is_ZeroCrossCh1_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_ZeroCrossCh1_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_ZeroCrossCh1_allowed
        return state_ok
        
    def read_LevelCh0(self, attr):
        self.debug_stream("In read_LevelCh0()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.LevelCh0_read) ENABLED START -----#
        try:
            ZeroCross, self.attr_LevelCh0_read = self._instrument.getInputCFD(0)
            attr.set_value(self.attr_LevelCh0_read)
        except Exception,e:
            self.set_status("Exception with LevelCh0: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.LevelCh0_read
        
    def write_LevelCh0(self, attr):
        self.debug_stream("In write_LevelCh0()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.LevelCh0_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setInputCFD(0,CFDLevel=data)
                ZeroCross, self.attr_LevelCh0_read = self._instrument.getInputCFD(0)
                self.fireEventsList([['LevelCh0',self.attr_LevelCh0_read]])
            else:
                self.attr_LevelCh0_read = data
        except Exception, e:
            self.error_stream("Exception with LevelCh0: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.LevelCh0_write
        
    def is_LevelCh0_allowed(self, attr):
        self.debug_stream("In is_LevelCh0_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_LevelCh0_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_LevelCh0_allowed
        return state_ok
        
    def read_LevelCh1(self, attr):
        self.debug_stream("In read_LevelCh1()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.LevelCh1_read) ENABLED START -----#
        try:
            ZeroCross, self.attr_LevelCh1_read = self._instrument.getInputCFD(1)
            attr.set_value(self.attr_LevelCh1_read)
        except Exception,e:
            self.set_status("Exception with LevelCh1: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.LevelCh1_read
        
    def write_LevelCh1(self, attr):
        self.debug_stream("In write_LevelCh1()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.LevelCh1_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setInputCFD(1,CFDLevel=data)
                ZeroCross, self.attr_LevelCh1_read = self._instrument.getInputCFD(1)
                self.fireEventsList([['LevelCh1',self.attr_LevelCh1_read]])
            else:
                self.attr_LevelCh1_read = data
        except Exception, e:
            self.error_stream("Exception with LevelCh1: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.LevelCh1_write
        
    def is_LevelCh1_allowed(self, attr):
        self.debug_stream("In is_LevelCh1_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_LevelCh1_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_LevelCh1_allowed
        return state_ok
        
    def read_Resolution(self, attr):
        self.debug_stream("In read_Resolution()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Resolution_read) ENABLED START -----#
        try:
            self.attr_Resolution_read = self._instrument.getResolution()
            attr.set_value(self.attr_Resolution_read)
        except Exception,e:
            self.set_status("Exception with Resolution: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Resolution_read
        
    def write_Resolution(self, attr):
        self.debug_stream("In write_Resolution()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.Resolution_write) ENABLED START -----#
        try:
            if self._instrument:
                binning = self._fromResolutionKnowBinning(data)
                self._instrument.setBinning(binning)
                self.attr_Binning_read = self._instrument.getBinning()
                self.attr_Resolution_read = self._instrument.getResolution()
                self.fireEventsList([['Binning',self.attr_Binning_read],
                                     ['Resolution',self.attr_Resolution_read]])
            else:
                self.attr_Resolution_read = data
        except Exception, e:
            self.error_stream("Exception with Resolution: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#    //    PH_PhotonCounter.Resolution_write
        
    def is_Resolution_allowed(self, attr):
        self.debug_stream("In is_Resolution_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Resolution_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Resolution_allowed
        return state_ok
        
    def read_Binning(self, attr):
        self.debug_stream("In read_Binning()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Binning_read) ENABLED START -----#
        try:
            self.attr_Binning_read = self._instrument.getBinning()
            attr.set_value(self.attr_Binning_read)
        except Exception,e:
            self.set_status("Exception with Binning: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Binning_read
        
    def write_Binning(self, attr):
        self.debug_stream("In write_Binning()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.Binning_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setBinning(data)
                self.attr_Binning_read = self._instrument.getBinning()
                self.attr_Resolution_read = self._instrument.getResolution()
                self.fireEventsList([['Binning',self.attr_Binning_read],
                                     ['Resolution',self.attr_Resolution_read]])
            else:
                self.attr_Binning_read = data
        except Exception, e:
            self.error_stream("Exception with Binning: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Binning_write
        
    def is_Binning_allowed(self, attr):
        self.debug_stream("In is_Binning_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Binning_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Binning_allowed
        return state_ok
        
    def read_BaseResolution(self, attr):
        self.debug_stream("In read_BaseResolution()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.BaseResolution_read) ENABLED START -----#
        try:
            self.attr_BaseResolution_read = self._instrument.getBaseResolution()
            attr.set_value(self.attr_BaseResolution_read)
        except Exception,e:
            self.set_status("Exception with BaseResolution: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.BaseResolution_read
        
    def is_BaseResolution_allowed(self, attr):
        self.debug_stream("In is_BaseResolution_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_BaseResolution_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_BaseResolution_allowed
        return state_ok
        
    def read_Offset(self, attr):
        self.debug_stream("In read_Offset()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Offset_read) ENABLED START -----#
        try:
            self.attr_Offset_read = self._instrument.getOffset()
            attr.set_value(self.attr_Offset_read)
        except Exception,e:
            self.set_status("Exception with Offset: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Offset_read
        
    def write_Offset(self, attr):
        self.debug_stream("In write_Offset()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.Offset_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setOffset(data)
                self.attr_Offset_read = self._instrument.getOffset()
                self.fireEventsList([['Offset',self.attr_Offset_read]])
            else:
                self.attr_Offset_read = data
        except Exception, e:
            self.error_stream("Exception with Offset: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Offset_write
        
    def is_Offset_allowed(self, attr):
        self.debug_stream("In is_Offset_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Offset_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Offset_allowed
        return state_ok
        
    def read_CountRateCh0(self, attr):
        self.debug_stream("In read_CountRateCh0()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.CountRateCh0_read) ENABLED START -----#
        try:
            self.attr_CountRateCh0_read = self._instrument.getCountRate(0)
            attr.set_value(self.attr_CountRateCh0_read)
        except Exception,e:
            self.set_status("Exception with CountRateCh0: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.CountRateCh0_read
        
    def is_CountRateCh0_allowed(self, attr):
        self.debug_stream("In is_CountRateCh0_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_CountRateCh0_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_CountRateCh0_allowed
        return state_ok
        
    def read_CountRateCh1(self, attr):
        self.debug_stream("In read_CountRateCh1()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.CountRateCh1_read) ENABLED START -----#
        try:
            self.attr_CountRateCh1_read = self._instrument.getCountRate(1)
            attr.set_value(self.attr_CountRateCh1_read)
        except Exception,e:
            self.set_status("Exception with CountRateCh1: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.CountRateCh1_read
        
    def is_CountRateCh1_allowed(self, attr):
        self.debug_stream("In is_CountRateCh1_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_CountRateCh1_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_CountRateCh1_allowed
        return state_ok
        
    def read_OverflowStopper(self, attr):
        self.debug_stream("In read_OverflowStopper()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.OverflowStopper_read) ENABLED START -----#
        try:
            self.attr_OverflowStopper_read,stopperCt = self._instrument.getStopOverflow()
            attr.set_value(self.attr_OverflowStopper_read)
        except Exception,e:
            self.set_status("Exception with StopOverflow: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.OverflowStopper_read
        
    def write_OverflowStopper(self, attr):
        self.debug_stream("In write_OverflowStopper()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.OverflowStopper_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setStopOverflow(stop=data)
                self.attr_OverflowStopper_read,stopperCt = self._instrument.getStopOverflow()
                self.fireEventsList([['OverflowStopper',self.attr_OverflowStopper_read]])
            else:
                self.attr_OverflowStopper_read = data
        except Exception, e:
            self.error_stream("Exception with OverflowStopper: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.OverflowStopper_write
        
    def is_OverflowStopper_allowed(self, attr):
        self.debug_stream("In is_OverflowStopper_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_OverflowStopper_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_OverflowStopper_allowed
        return state_ok
        
    def read_OverflowStopperThreshold(self, attr):
        self.debug_stream("In read_OverflowStopperThreshold()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.OverflowStopperThreshold_read) ENABLED START -----#
        try:
            stopper,self.attr_OverflowStopperThreshold_read = self._instrument.getStopOverflow()
            attr.set_value(self.attr_OverflowStopperThreshold_read)
        except Exception,e:
            self.set_status("Exception with StopOverflow Threshold: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.OverflowStopperThreshold_read
        
    def write_OverflowStopperThreshold(self, attr):
        self.debug_stream("In write_OverflowStopperThreshold()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.OverflowStopperThreshold_write) ENABLED START -----#
        try:
            if data == 0:
                #this is avoided by tango min value, but this is required
                #because when recover from memorized but without previous data,
                #it tries to write a 0.
                return
            if self._instrument:
                self._instrument.setStopOverflow(count=data)
                stopper,self.attr_OverflowStopperThreshold_read = self._instrument.getStopOverflow()
                self.fireEventsList([['OverflowStopperThreshold',self.attr_OverflowStopperThreshold_read]])
            else:
                self.attr_OverflowStopperThreshold_read = data
        except Exception, e:
            self.error_stream("Exception with OverflowStopperThreshold: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.OverflowStopperThreshold_write
        
    def is_OverflowStopperThreshold_allowed(self, attr):
        self.debug_stream("In is_OverflowStopperThreshold_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_OverflowStopperThreshold_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_OverflowStopperThreshold_allowed
        return state_ok
        
    def read_AcquisitionTime(self, attr):
        self.debug_stream("In read_AcquisitionTime()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.AcquisitionTime_read) ENABLED START -----#
        try:
            self.attr_AcquisitionTime_read = self._instrument.getAcquisitionTime()/1000.
            attr.set_value(self.attr_AcquisitionTime_read)
        except Exception,e:
            self.set_status("Exception with Acquisition Time: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.AcquisitionTime_read
        
    def write_AcquisitionTime(self, attr):
        self.debug_stream("In write_AcquisitionTime()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.AcquisitionTime_write) ENABLED START -----#
        try:
            if self._instrument:
                self._instrument.setAcquisitionTime(int(data*1000))
                self.attr_AcquisitionTime_read = self._instrument.getAcquisitionTime()/1000.
                self.fireEventsList([['AcquisitionTime',self.attr_AcquisitionTime_read]])
            else:
                self.attr_AcquisitionTime_read = data
        except Exception, e:
            self.error_stream("Exception with AcquisitionTime: %s"%e)
            raise e
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.AcquisitionTime_write
        
    def is_AcquisitionTime_allowed(self, attr):
        self.debug_stream("In is_AcquisitionTime_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_AcquisitionTime_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_AcquisitionTime_allowed
        return state_ok
        
    def read_Flags(self, attr):
        self.debug_stream("In read_Flags()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Flags_read) ENABLED START -----#
        try:
            self.attr_Flags_read = self._instrument.getFlags()
            atrt.set_value(self.attr_Flags_read)
        except Exception,e:
            self.set_status("Exception with Flags: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Flags_read
        
    def is_Flags_allowed(self, attr):
        self.debug_stream("In is_Flags_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Flags_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Flags_allowed
        return state_ok
        
    def read_IntegralCount(self, attr):
        self.debug_stream("In read_IntegralCount()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.IntegralCount_read) ENABLED START -----#
        try:
            self.attr_IntegralCount_read = self._instrument.integralCount()
            attr.set_value(self.attr_IntegralCount_read)
        except Exception,e:
            self.set_status("Exception with integralcount: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.IntegralCount_read
        
    def is_IntegralCount_allowed(self, attr):
        self.debug_stream("In is_IntegralCount_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_IntegralCount_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_IntegralCount_allowed
        return state_ok
        
    def read_HistogramMaxValue(self, attr):
        self.debug_stream("In read_HistogramMaxValue()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.HistogramMaxValue_read) ENABLED START -----#
        try:
            self.attr_HistogramMaxValue_read = long(np.array(self._instrument.getHistogram()).max())
            attr.set_value(self.attr_HistogramMaxValue_read)
        except Exceptio,e:
            self.error_stream("In read_HistogramMaxValue() Exception: %s"%e)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.HistogramMaxValue_read
        
    def is_HistogramMaxValue_allowed(self, attr):
        self.debug_stream("In is_HistogramMaxValue_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_HistogramMaxValue_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_HistogramMaxValue_allowed
        return state_ok
        
    def read_ElapsedMeasTime(self, attr):
        self.debug_stream("In read_ElapsedMeasTime()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.ElapsedMeasTime_read) ENABLED START -----#
        try:
            self.attr_ElapsedMeasTime_read = \
                                    self._instrument.getElapsedMeasTime()/1000.
            attr.set_value(self.attr_ElapsedMeasTime_read)
        except Exception,e:
            self.set_status("Exception with ElapsedMeasTime: %s"%e,
                            important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#    //    PH_PhotonCounter.ElapsedMeasTime_read
        
    def is_ElapsedMeasTime_allowed(self, attr):
        self.debug_stream("In is_ElapsedMeasTime_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_ElapsedMeasTime_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_ElapsedMeasTime_allowed
        return state_ok
        
    def read_Warnings(self, attr):
        self.debug_stream("In read_Warnings()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Warnings_read) ENABLED START -----#
        try:
            self.attr_Warnings_read = self._instrument.getWarningsText()
            attr.set_value(self.attr_Warnings_read)
        except Exception,e:
            self.set_status("Exception with Warnings: %s"%e,
                            important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#    //    PH_PhotonCounter.Warnings_read
        
    def is_Warnings_allowed(self, attr):
        self.debug_stream("In is_Warnings_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Warnings_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Warnings_allowed
        return state_ok
        
    def read_HardwareDebugInfo(self, attr):
        self.debug_stream("In read_HardwareDebugInfo()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.HardwareDebugInfo_read) ENABLED START -----#
        try:
            self.attr_HardwareDebugInfo_read = self._instrument.getHardwareDebugInfo()
            attr.set_value(self.attr_HardwareDebugInfo_read)
        except Exception,e:
            self.set_status("Exception with HardwareDebugInfo: %s"%e,
                            important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#    //    PH_PhotonCounter.HardwareDebugInfo_read
        
    def is_HardwareDebugInfo_allowed(self, attr):
        self.debug_stream("In is_HardwareDebugInfo_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_HardwareDebugInfo_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_HardwareDebugInfo_allowed
        return state_ok
        
    def read_TimeBetweenChanging(self, attr):
        self.debug_stream("In read_TimeBetweenChanging()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.TimeBetweenChanging_read) ENABLED START -----#
        attr.set_value(self.getTimeBetweenChanging())
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.TimeBetweenChanging_read
        
    def write_TimeBetweenChanging(self, attr):
        self.debug_stream("In write_TimeBetweenChanging()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.TimeBetweenChanging_write) ENABLED START -----#
        self.setTimeBetweenChangin(data)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.TimeBetweenChanging_write
        
    def read_TimeHoldingAlarm(self, attr):
        self.debug_stream("In read_TimeHoldingAlarm()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.TimeHoldingAlarm_read) ENABLED START -----#
        attr.set_value(self.getTimeHoldingAlarm())
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.TimeHoldingAlarm_read
        
    def write_TimeHoldingAlarm(self, attr):
        self.debug_stream("In write_TimeHoldingAlarm()")
        data=attr.get_write_value()
        #----- PROTECTED REGION ID(PH_PhotonCounter.TimeHoldingAlarm_write) ENABLED START -----#
        if data == 0:
            #this is avoided by tango min value, but this is required 
            #because when recover from memorized but without previous data,
            #it tries to write a 0.
            return
        self.setTimeHoldingAlarm(data)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.TimeHoldingAlarm_write
        
    def read_Histogram(self, attr):
        self.debug_stream("In read_Histogram()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Histogram_read) ENABLED START -----#
        try:
            self.attr_Histogram_read = self._instrument.getHistogram()
            attr.set_value(self.attr_Histogram_read)
        except Exception,e:
            self.set_status("Exception with Histogram: %s"%e, important=True)
            self.set_state(PyTango.DevState.FAULT)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Histogram_read
        
    def is_Histogram_allowed(self, attr):
        self.debug_stream("In is_Histogram_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
                PyTango.DevState.INIT,
                PyTango.DevState.OFF,
                PyTango.DevState.STANDBY])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Histogram_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Histogram_allowed
        return state_ok
        
    
    
        #----- PROTECTED REGION ID(PH_PhotonCounter.initialize_dynamic_attributes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    PH_PhotonCounter command methods
    #-----------------------------------------------------------------------------
    
    def On(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In On()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.On) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.On
        
    def is_On_allowed(self):
        self.debug_stream("In is_On_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.ON,
            PyTango.DevState.RUNNING,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_On_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_On_allowed
        return state_ok
        
    def Off(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Off()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Off) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Off
        
    def is_Off_allowed(self):
        self.debug_stream("In is_Off_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Off_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Off_allowed
        return state_ok
        
    def Start(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Start()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Start) ENABLED START -----#
        self.continuousAcquisition()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Start
        
    def is_Start_allowed(self):
        self.debug_stream("In is_Start_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Start_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Start_allowed
        return state_ok
        
    def Stop(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Stop()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Stop) ENABLED START -----#
        self._acquisitionStop.set()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Stop
        
    def is_Stop_allowed(self):
        self.debug_stream("In is_Stop_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.OFF,
            PyTango.DevState.ON,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Stop_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Stop_allowed
        return state_ok
        
    def Acquire(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Acquire()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Acquire) ENABLED START -----#
        self.singleAcquisition()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Acquire
        
    def is_Acquire_allowed(self):
        self.debug_stream("In is_Acquire_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.OFF,
            PyTango.DevState.RUNNING,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Acquire_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Acquire_allowed
        return state_ok
        
    def Abort(self):
        """ 
        
        :param : 
        :type: PyTango.DevVoid
        :return: 
        :rtype: PyTango.DevVoid """
        self.debug_stream("In Abort()")
        #----- PROTECTED REGION ID(PH_PhotonCounter.Abort) ENABLED START -----#
        self._acquisitionStop.set()
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Abort
        
    def is_Abort_allowed(self):
        self.debug_stream("In is_Abort_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.FAULT,
            PyTango.DevState.INIT,
            PyTango.DevState.OFF,
            PyTango.DevState.ON,
            PyTango.DevState.STANDBY])
        #----- PROTECTED REGION ID(PH_PhotonCounter.is_Abort_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.is_Abort_allowed
        return state_ok
        
    def Exec(self, argin):
        """ Dangerous command that allow to eval internally python code
        
        :param argin: 
        :type: PyTango.DevString
        :return: 
        :rtype: PyTango.DevString """
        self.debug_stream("In Exec()")
        argout = ''
        #----- PROTECTED REGION ID(PH_PhotonCounter.Exec) ENABLED START -----#
        cmd = argin
        L = self._locals
        G = self._globals
        try:
            try:
                # interpretation as expression
                result = eval(cmd, G, L)
            except SyntaxError:
                # interpretation as statement
                exec cmd in G, L
                result = L.get("y")

        except Exception, exc:
            # handles errors on both eval and exec level
            result = exc

        if type(result)==StringType:
            return result
        elif isinstance(result, BaseException):
            return "%s!\n%s" % (result.__class__.__name__, str(result))
        else:
            return pprint.pformat(result)
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.Exec
        return argout
        

    #----- PROTECTED REGION ID(PH_PhotonCounter.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.programmer_methods

class PH_PhotonCounterClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(PH_PhotonCounter.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`PH_PhotonCounter.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(PH_PhotonCounter.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'SerialNumber':
            [PyTango.DevString,
            "Serial number of the instrument to contact",
            [] ],
        'Simulation':
            [PyTango.DevBoolean,
            "Property to configure the device to, instead of use an instrument, simulate it.",
            [False]],
        }


    #    Command definitions
    cmd_list = {
        'On':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Off':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Start':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Stop':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Acquire':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Abort':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'Exec':
            [[PyTango.DevString, "none"],
            [PyTango.DevString, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        }


    #    Attribute definitions
    attr_list = {
        'InstrumentModel':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Model",
                'description': "Name given by the instrument about its model.",
            } ],
        'InstrumentPartnum':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "PartNum",
                'description': "Name given by the instrument about its partnum.",
            } ],
        'InstrumentVersion':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "firmware version",
                'description': "Firmware version of the instrument.",
            } ],
        'SyncDivider':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Divider",
                'description': "Programable divider of the sync input. This allows to reduce the sync input rate.",
                'Memorized':"true"
            } ],
        'ZeroCrossCh0':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Zero Cross Channel 0",
                'unit': "mV",
                'description': "Zero cross level of the Constant Fraction Discriminator (CFD) for the channel 0",
                'Memorized':"true"
            } ],
        'ZeroCrossCh1':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Zero Cross Channel 1",
                'unit': "mV",
                'description': "Zero cross level of the Constant Fraction Discriminator (CFD) for the channel 1",
                'Memorized':"true"
            } ],
        'LevelCh0':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Level Channel 0",
                'unit': "mV",
                'description': "Discriminator level of the Constant Fraction Discriminator (CFD) for the channel 0",
                'Memorized':"true"
            } ],
        'LevelCh1':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Level Channel 1",
                'unit': "mV",
                'description': "Discriminator level of the Constant Fraction Discriminator (CFD) for the channel 1",
                'Memorized':"true"
            } ],
        'Resolution':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Resolution",
                'unit': "ps",
                'description': "Acquisition resolution.",
                'Memorized':"true_without_hard_applied"
            } ],
        'Binning':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Binning",
                'description': "To configure the resolution. Steps from 0 to 7 means resolutions 4, 8, 16, 32, ..., 512 ps.",
                'Memorized':"true"
            } ],
        'BaseResolution':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Base Resolution",
                'unit': "ps",
                'description': "The very basic resolution where no binning can be applied.",
            } ],
        'Offset':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Offset",
                'unit': "ns",
                'description': "Delay the acquisition window relatively to the sync frame.",
                'Memorized':"true"
            } ],
        'CountRateCh0':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Count Rate Channel 0",
                'unit': "cps",
                'format': "%g",
            } ],
        'CountRateCh1':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Count Rate Channel 1",
                'unit': "cps",
                'format': "%g",
            } ],
        'OverflowStopper':
            [[PyTango.DevBoolean,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Overflow stopper",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'OverflowStopperThreshold':
            [[PyTango.DevULong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Overflow threshold",
                'max value': "65536",
                'min value': "1",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'AcquisitionTime':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Acquisition time",
                'unit': "s",
                'Memorized':"true"
            } ],
        'Flags':
            [[PyTango.DevShort,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'IntegralCount':
            [[PyTango.DevLong64,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Integration",
                'unit': "counts",
            } ],
        'HistogramMaxValue':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Histogram Maximum Value",
                'description': "From read histogram, its maximum value",
            } ],
        'ElapsedMeasTime':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "elapsed measurement time",
                'unit': "s",
            } ],
        'Warnings':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Warnings",
                'description': "Human readable text from the instrument warning codes.",
            } ],
        'HardwareDebugInfo':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "DebugInfo",
                'description': "Instrument debug information.",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'TimeBetweenChanging':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time Between Changing",
                'unit': "seconds",
                'max value': "3",
                'min value': "0.1",
                'description': "Internal parameter of the device to configure the reading frequency to the instrument for intermediate values.",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'TimeHoldingAlarm':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label': "Time Holding Alarm",
                'unit': "seconds",
                'max value': "3",
                'min value': "1",
                'description': "Internal parameter to configure how much time the alarm state is hold to allow the user to record the information.",
                'Display level': PyTango.DispLevel.EXPERT,
                'Memorized':"true"
            } ],
        'Histogram':
            [[PyTango.DevLong,
            PyTango.SPECTRUM,
            PyTango.READ, 65536]],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(PH_PhotonCounterClass,PH_PhotonCounter,'PH_PhotonCounter')
        #----- PROTECTED REGION ID(PH_PhotonCounter.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	PH_PhotonCounter.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
